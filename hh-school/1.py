"""
У HR Маши на столе лежат две стопки резюме, размерами n и m, в каждом из резюме указана зарплата,
числа a[0..n-1] для одной стопки, и b[0..m-1] для второй. Нулевой индекс указывает на верхнее резюме в стопке.


Маша устанавливает значение s максимальной суммы зарплат и предлагает очень активному стажеру Саше сыграть в игру:

- За каждый ход Саша может взять одно верхнее резюме из любой стопки и забрать себе в работу
- Саша считает сумму всех зарплат из резюме, которые он взял. Он может брать новые резюме из стопок только
таким образом, чтобы эта сумма не превышала s
- Игра заканчивается, если Саша больше не может брать резюме

Нужно выяснить, какое максимальное количество резюме Саша мог бы забрать себе в работу, если бы тоже знал зарплаты,
указанные в каждом резюме.

Входные данные (поступают в стандартный поток ввода)
Первая строка – целые числа n, m и s через пробел (1≤n≤10 000, 1≤m≤10 000, 1≤s≤200 000 000)

Далее идут строки с зарплатами резюме в стопках. Всего строк столько, сколько резюме в большей из стопок, на каждой строке один из вариантов:

- два целых числа a и b через пробел (1≤a≤10 000, 1≤b≤10 000),
- a и символ - (если во второй стопке больше нет резюме) через пробел (1≤a≤10 000)
- символ - (если в первой стопке больше нет резюме) и b через пробел (1≤b≤10 000)
Все входные данные наших тестов всегда соблюдают указанные параметры, дополнительные проверки не требуются


Выходные данные (ожидаются в стандартном потоке вывода)
Одно целое число, максимальное количество резюме
"""

from array import array

n, m, s = tuple(map(int, input().split()))
n_array, m_array = array('I'), array('I')
while n or m:
    n_num, m_num = input().split()
    if n:
        n_array.append(int(n_num))
        n -= 1
    if m:
        m_array.append(int(m_num))
        m -= 1


def sum_counter(arr: array):
    current_sum = 0
    count_and_sum = [(0, 0)]
    for i, v in enumerate(arr, start=1):
        current_sum += v
        if current_sum > s:
            return count_and_sum
        count_and_sum.append((i, current_sum))
    return count_and_sum


def max_count(a_count, a_sum, b_list):
    if s == a_sum:
        return a_count
    available_s = s - a_sum
    for b_count, b_sum in reversed(b_list):
        if b_sum <= available_s:
            return a_count + b_count
    return a_count


n_list, m_list = sum_counter(n_array), sum_counter(m_array)
print(max(max_count(*n_list[-1], m_list), max_count(*m_list[-1], n_list)))
